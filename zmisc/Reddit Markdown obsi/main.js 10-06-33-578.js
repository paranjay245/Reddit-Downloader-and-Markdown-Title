/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RedditMarkdownLink
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var DEFAULT_SETTINGS = {
  pythonPath: "python3"
};
var RedditMarkdownLink = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "convert-reddit-links",
      name: "Convert Links to Markdown",
      editorCallback: (editor) => this.convertLinks(editor)
    });
    this.addSettingTab(new RedditMarkdownLinkSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async convertLinks(editor) {
    const content = editor.getValue();
    const urlRegex = /https?:\/\/[^\s)]+/g;
    const urls = content.match(urlRegex) || [];
    try {
      const { stdout: cwd } = await execAsync("pwd");
      const pluginDir = cwd.trim();
      const scriptPath = path.join(pluginDir, "reddit_link_converter.py");
      if (!fs.existsSync(scriptPath)) {
        throw new Error(`Python script not found at: ${scriptPath}`);
      }
      const tempFile = path.join(pluginDir, "urls.json");
      fs.writeFileSync(tempFile, JSON.stringify(urls));
      const { stdout } = await execAsync(`${this.settings.pythonPath} "${scriptPath}" < "${tempFile}"`);
      fs.unlinkSync(tempFile);
      const results = JSON.parse(stdout);
      const markdownList = results.map(
        (result) => `- [${result.title}](${result.url})`
      ).join("\n");
      editor.setValue(markdownList);
    } catch (error) {
      console.error("Error running Python script:", error);
      new import_obsidian.Notice("Error converting links. Check console for details.");
    }
  }
};
var RedditMarkdownLinkSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Reddit Markdown Link Settings" });
    new import_obsidian.Setting(containerEl).setName("Python Path").setDesc("Path to Python executable (e.g., python3)").addText((text) => text.setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
